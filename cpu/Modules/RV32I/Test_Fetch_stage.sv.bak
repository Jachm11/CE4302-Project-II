module Fetch_stage_tb;

  // Parámetros del módulo
  parameter CLOCK_PERIOD = 10;
  parameter RESET_TIME = 5;

  // Señales de entrada
  logic [1:0] PC_source_E_tb;
  logic [31:0] PC_plus_4_E_tb;
  logic [31:0] ALU_result_0_E_tb;
  logic enable_fetch_tb;
  logic branch_prediction_D_tb;
  logic [31:0] predicted_PC_D_tb;
  logic clock_tb;
  logic async_reset_tb;

  // Señales de salida
  logic [31:0] PC_F_tb;
  logic [31:0] PC_plus_4_F_tb;

  // Instancia del módulo bajo prueba
  Fetch_stage uut (
    .PC_source_E(PC_source_E_tb),
    .PC_plus_4_E(PC_plus_4_E_tb),
    .ALU_result_0_E(ALU_result_0_E_tb),
    .enable_fetch(enable_fetch_tb),
    .branch_prediction_D(branch_prediction_D_tb),
    .predicted_PC_D(predicted_PC_D_tb),
    .clock(clock_tb),
    .async_reset(async_reset_tb),
    .PC_F(PC_F_tb),
    .PC_plus_4_F(PC_plus_4_F_tb)
  );

  // Generación de clock
  initial begin
    clock_tb = 0;
    forever #CLOCK_PERIOD clock_tb = ~clock_tb;
  end

  // Generación de reset asincrónico
  initial begin
    async_reset_tb = 1;
    #RESET_TIME async_reset_tb = 0;
  end

  // Test de ejemplo con assert
  initial begin
    // Configuración de las entradas
    PC_source_E_tb = 2'b00;
    PC_plus_4_E_tb = 32'h0000_0004;
    ALU_result_0_E_tb = 32'h0000_0008;
    enable_fetch_tb = 1;
    branch_prediction_D_tb = 0;
    predicted_PC_D_tb = 32'h0000_0010;

    // Esperar un ciclo de clock antes de verificar la salida
    #CLOCK_PERIOD;

    // Verificar la salida usando assert
    assert (PC_F_tb == 32'h0000_0010) else $fatal("Error: PC_F no coincide con el valor esperado");
    assert (PC_plus_4_F_tb == 32'h0000_0014) else $fatal("Error: PC_plus_4_F no coincide con el valor esperado");

    // Finalizar la simulación
    $stop;
  end

endmodule
